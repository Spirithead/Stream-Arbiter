# Stream-Arbiter
Устройство представляет собой потоковый арбитр с политикой Quality-of-Service. Оно было реализовано в качестве конечного автомата с двумя состояниями - CALC_QOS 
и OPERATE. В первом состоянии вычисляется максимальный приоритет из всех потоков, во втором выбирается сам поток и выводятся его пакеты данных. В связи с данной архитектурой при переключении потоков формируется задержка вывода пакетов в один такт. Cделано это было для стабильного формирования значения максимального приоритета в регистре.

Устройство состоит из двух модулей: сам арбитр stream_arbiter и компаратора comparator. Рассмотрим подробнее принцип работы модулей:

Компаратор последовательно в цикле сравнивает приоритеты поток и сохраняет максимальный. При этом поток может участвовать в сравнении, если его данные действительны (s_valid_i[i]) и этот поток ещё не был обслужен (!served[i]). Сам компаратор может проводить сравнения только при выставленном в единицу флаге can_calc.

Арбитр начинает работу в состоянии CALC_QOS. В этом состоянии флаг can_calc и флаг действительности выходных данных (m_valid_o) сбрасываются и производится переход в состояние OPERATE. В нём либо выбирается новый поток (если флаг запрета переключения потока во время передачи транзакции locked сброшен), либо потактно передаются на выход данные с выбранного потока.

Выбор потока проводится только после окончания вывода предыдущей транзакции. Выбор производится по принципу Round-Robin: если одновременно поступают транзакции с нескольких поток с максимальным или нулевым приоритетом, на выход передаются транзакции циклически поочерёдно. Очерёдность выбора потока обеспечивается с помощью массива флагов served: если поток был выбран, соответствующий бит served[i] будет установлен в единицу и поток не будет выбран при следующем выборе. Если же все потоки, в данный момент передающие данные, уже выбирались для передачи, цикл Round-Robin был пройден и, соотвественно, все биты served будут сброшены и эти потоки снова смогут быть выбраны. Факт окончания цикла устанавливается с помощью операции XOR над переменными s_valid_i и served: если биты, равные 1, (т.е. номера) валидных потоков и обслуженных потоков совпадают, то в результате операции получится 0. Отличный от нуля результат получится если битов валидных потоков окажется больше (битов обслуженных потоков не может получиться больше, т.к. все потоки помечаются как необслуженные, как только они становятся невалидными). При выборе фиксируется номер потока, флаги locked, m_valid_o и флаг готовности принять данные s_ready_o[i] устанавливаются в единицу и данные начинают передаваться на выход.

Если с потока был передан сигнал о последнем пакете транзакции (s_last_i[curr_stream]), флаги locked и s_ready_o[curr_stream] сбрастываются, флаг can_calc устанавливается, производится переход в состояние CALC_QOS.

Рассмотрим симуляцию. Для тестирования были сымитированы 3 потока следующего содержания:
  1. поток 0: приоритет 2, пакеты в транзакции: 2, 4, 8, 9
  2. поток 1: приоритет 0, пакеты в транзакции: 3, 6, 3, 1
  3. поток 2: приоритет 6, пакеты в транзакции: A, C, 0, 1, 4, F

Как видно на диаграмме ниже, были последовательно выведены пакеты со всех потоков в порядке, вытекающем из принципов работы арбитра.

<img width="673" alt="d1" src="https://github.com/Spirithead/Stream-Arbiter/assets/90761881/6c519f05-d74c-44cc-adb5-db81b589f585">


Тестбенч, тестовые векторы и скрипт для запуска симуляции в ModelSim, а также отчёты об анализе, синтезе и таймингах прилагаются в репозитории. Синтез был произведён 
вручную в среде Quartus для ПЛИС Cyclone V на частоте 200 МГц.

