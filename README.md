# Stream-Arbiter
Устройство представляет собой потоковый арбитр с политикой Quality-of-Service. Оно было реализовано в качестве конечного автомата с двумя состояниями - CALC_QOS, SELECT_STREAM и OPERATE. В первом состоянии вычисляется текущий приоритет из всех потоков и его индекс, во втором выбирается сам поток, в третьем выводятся его пакеты данных. В связи с данной архитектурой при переключении потоков формируется задержка вывода пакетов в два такта. Cделано это было для стабильного формирования значения приоритета в регистре.

Устройство состоит из двух модулей: сам арбитр stream_arbiter и компаратора comparator (и его составных модулей comp2 и comp2s). Рассмотрим подробнее принцип работы модулей:

Компаратор представляет из себя "пирамиду", состоящую из более простых компараторов (comp2, comp2s) для двух чисел (см. схему). Такой компаратор способен сравнивать приоритеты максимум 8 потоков, однако благодаря модульной структуре он может быть расширен для большего числа потоков. Компаратор не просто считает максимальный приоритет, но и выбирает конкретный поток (с учётом нулевых приоритетов). Поэтому на выход подаётся индекс потока и его приоритет.

Первый слой состоит из "стартовых" компараторов comp2s. Они работают по фронту синхросигнала и по сигналу, разрешающему сравнение (can_calc), соответственно, они сохраняют результат в синхронных регистрах. Остальные же компараторы comp2 принимают на вход результат работы предыдущих компараторов, сохраняют свой результат в защёлках и передают его дальше (поэтому в коде применяются исключительно блокирующие присваивания).

Компараторы сравнивают приоритеты с учётом валидности потоков и того, выбирались ли они ранее (массив флагов served). Если ни один поток не может быть выбран, на выход подаётся комбинация дефолтных значений: приоритет 0 и индекс <макс. индекс> + 1 (т.е. он будет равняться параметру STREAM_COUNT).

Кроме того проверяется наличие нулевых приоритетов. Если они имеются, то сравниваются индексы таких потоков и вычисляется наименьший.

По итогу работы этих простейших модулей в верхнем модуле компаратора имеются: максимальный приоритет, его индекс и индекс нулевого приоритета. Выбирается из этих двух потоков один с наименьшим индексом. Таким образом реализуется последовательность выбора потоков.

Стоит отметить, что если на вход подаётся меньше восьми потоков, то входные данные будут изменены под формат, пригодный для компаратора. Например, если имеется 5 потоков, то 5-разрядная шина valid станет 8-разрядной. Таким образом добавляются несуществующие потоки. Они помечаются как невалидные, поэтому они никогда не будут влиять на результат. (Наглядно: 11111 => 11111000, последние 3 бита принадлежат несуществующим потокам, они невалидны). Аналогично с приоритетами и флагами served. 

Арбитр начинает работу в состоянии CALC_QOS. В этом состоянии флаг can_calc и флаг действительности выходных данных (m_valid_o) сбрасываются и производится переход в состояние OPERATE. В нём либо выбирается новый поток (если флаг запрета переключения потока во время передачи транзакции locked сброшен), либо потактно передаются на выход данные с выбранного потока.

Выбор потока проводится только после окончания вывода предыдущей транзакции. Выбор производится по принципу Round-Robin: если одновременно поступают транзакции с нескольких поток с максимальным или нулевым приоритетом, на выход передаются транзакции циклически поочерёдно. Очерёдность выбора потока обеспечивается с помощью массива флагов served: если поток был выбран, соответствующий бит served[i] будет установлен в единицу и поток не будет выбран при следующем выборе. Если же все потоки, в данный момент передающие данные, уже выбирались для передачи, цикл Round-Robin был пройден и, соотвественно, все биты served будут сброшены и эти потоки снова смогут быть выбраны. Факт окончания цикла устанавливается с помощью операции XOR над переменными s_valid_i и served: если биты, равные 1, (т.е. номера) валидных потоков и обслуженных потоков совпадают, то в результате операции получится 0. Отличный от нуля результат получится если битов валидных потоков окажется больше (битов обслуженных потоков не может получиться больше, т.к. все потоки помечаются как необслуженные, как только они становятся невалидными). При выборе фиксируется номер потока, флаги locked, m_valid_o и флаг готовности принять данные s_ready_o[i] устанавливаются в единицу и данные начинают передаваться на выход.

Если с потока был передан сигнал о последнем пакете транзакции (s_last_i[curr_stream]), флаги locked и s_ready_o[curr_stream] сбрастываются, флаг can_calc устанавливается, производится переход в состояние CALC_QOS.

Рассмотрим симуляцию. Для тестирования были сымитированы 3 потока следующего содержания:
  1. поток 0: приоритет 2, пакеты в транзакции: 2, 4, 8, 9
  2. поток 1: приоритет 0, пакеты в транзакции: 3, 6, 3, 1
  3. поток 2: приоритет 6, пакеты в транзакции: A, C, 0, 1, 4, F

Как видно на диаграмме ниже, были последовательно выведены пакеты со всех потоков в порядке, вытекающем из принципов работы арбитра.

<img width="673" alt="d1" src="https://github.com/Spirithead/Stream-Arbiter/assets/90761881/6c519f05-d74c-44cc-adb5-db81b589f585">


Тестбенч, тестовые векторы и скрипт для запуска симуляции в ModelSim, а также отчёты об анализе, синтезе и таймингах прилагаются в репозитории. Синтез был произведён 
вручную в среде Quartus для ПЛИС Cyclone V на частоте 200 МГц.

